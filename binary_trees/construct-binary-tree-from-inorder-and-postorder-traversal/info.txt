{"id":588357122,"lang":"python3","time":"8 months, 3 weeks","timestamp":1637117226,"status_display":"Accepted","runtime":"236 ms","url":"/submissions/detail/588357122/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"90.2 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if len(inorder) == 0:\n            return None\n        if len(inorder) == 1:\n            return TreeNode(inorder[0], None, None)\n        \n        value = postorder[-1]\n        index = inorder.index(value)\n        lInorder = inorder[:index].copy()\n        rInorder = inorder[(index + 1):].copy()\n        lPostorder = []\n        rPostorder = []\n        \n        if len(rInorder) != 0:\n            split = rInorder[0]\n            splitIndex = postorder.index(split)\n            rPostorder = postorder[index:-1].copy()\n            lPostorder = postorder[:index].copy()\n        else:\n            lPostorder = postorder[:-1].copy()\n            \n                \n        node = TreeNode(value, None, None)\n        node.left = Solution.buildTree(self, lInorder, lPostorder)\n        node.right = Solution.buildTree(self, rInorder, rPostorder)\n        \n        return node  ","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal"}